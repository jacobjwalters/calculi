\section{Dependent Types via Singletons}
When moving from STLC to dependent types, our judgements themselves become more complicated.
To keep things simple, we'll only consider the simplest possible dependent type: the singleton.
In order to make the calculus non-trivial, we'll include the booleans as a base type.

\subsection{Presyntax}
Our calculus is defined over precontexts $\Gamma$, pretypes $A$, and preterms $t, c, e$.

\begin{bnf}
$\Gamma$ ::=
  | $\cdot$ : Empty context
  | $\Gamma, x \colon S$ : Variable weakening
  | $\Gamma, (x \colon A) \equiv t$ : Definition weakening
;;
$A$ ::=
  | $\Bool$ : Booleans
  | $\Singleton[A][t]$ : The singleton of $t \,\colon A$
;;
$t, c, e$ ::=
| $\true$ : Boolean value constructors
| $\false$
| $\when{c}{x}{A}{t}{e}$ : Boolean eliminator
| $\val[A][t]$ : Value constructor for $\Singleton[A][t]$
| $x, y, z, ...$ : Variables
\end{bnf}

Intuition for the boolean eliminator is that it acts like if-then-else, except it also binds the value of $c$ to $x$, and makes this available for $A$ to use.

\subsection{Judgements}
\subsubsection{Contexts}
Our contexts are snoclists of either variables (with associated types), or definitions (a variable paired with a term).
We have a judgement to declare that $\Gamma$ is a valid context:
\[
  \vdash \ctx{\Gamma}
\]

All empty contexts are valid:
\[
  \inference[Ctx-Emp]{}{\vdash \ctx{\cdot}}
\]

Given a valid context $\Gamma$, we can extend it with a variable:
\[
  \inference[Ctx-ExtVar]
  {\Gamma \vdash x : A}
  {\vdash \ctx{\Gamma, x : A}}
\]

Or, we can extend it with a definition:
\[
  \inference[Ctx-ExtLet]
  {\Gamma \vdash t : A}
  {\vdash \ctx{\Gamma, (x : A) \equiv t}}
\]
$x$ in this rule is just a name that refers to the term $t$.
We can envision this as a let binding.
We can think of our variables as de-Bruijn indexed, so shadowing isn't an issue.

For implementation, we consider the support of a context (i.e., the names of the variables used by said context).
It's too much work (as in, an open problem) to index our terms by their contexts, since we have to keep track of dependencies, so instead we index terms by their support.

\subsubsection{Types}
$A$ is a valid type in context $\Gamma$:
\[
  \Gamma \vdash \type{A}
\]

\subsubsection{Terms}
$t$ is a well typed term of type $A$ in context $\Gamma$:
\[
  \Gamma \vdash t : A
\]

\subsection{Relations}
We have three relations that we need to worry about, acting on contexts, types, and terms. We'll call them twinning (writ $\twin \Gamma \Delta$), convertibility (writ $\Gamma \vdash A \equiv B \dashv \Delta$), and judgemental equality (writ $\Gamma \vdash (t : A) \equiv (s : B) \dashv \Delta$) respectively.

\subsubsection{Twinning}
Introduced by Gundry \cite{gundry2013TypeInferenceHaskell} \cite{gundry2013TutorialImplementationDynamic}, a twinning relation allows us to ``twin'' the same variable appearing in two terms under different contexts with the same shape, where ``shape'' is defined via convertibility on types.

The twinning relation between contexts $\Gamma$ and $\Delta$ defines a bijective correspondence between $\Gamma$'s support and $\Delta$'s support, and ensures that corresponding variables in $\Gamma$ and $\Delta$ have the same shape, up to convertibility.

\[
  \inference[Twin-Emp]{}{\cdot \frown \cdot}
\]
\[
  \inference[Twin-ExtVar]
    { \Gamma \frown \Delta
    & \Gamma \vdash A \equiv B \dashv \Delta
    }
    { \Gamma, x : A \frown \Delta, y : B }
\]

\[
  \inference[Twin-ExtLet]
  { \twin{\Gamma}{\Delta}
  & \Gamma \vdash (t : A) \equiv (s : B) \dashv \Delta
  }
  {\twin{\Gamma, (x : A) \equiv t}{\Delta, (y : B) \equiv s}}
\]


\subsubsection{Convertibility}
Given two types $A$ and $B$, we define convertibility on $A$ and $B$ inductively. Assume $\Gamma$ and $\Delta$ are twinned.

\[
\inference[Conv-\Bool-Cong]{}{\Gamma \vdash \Bool \equiv \Bool \dashv \Delta}
\]
(we postulate the same for any other closed type)

For the singleton type:
\[
\inference[Conv-$\Singleton$-Cong]
    { \Gamma \vdash A \equiv B \dashv \Delta
    & \Gamma \vdash (t : A) \equiv (s : B) \dashv \Delta
    }
    { \Gamma \vdash \Singleton[A][t] \equiv \Singleton[B][s] \dashv \Delta }
\]

\jtodo{Convertibility for variables}

Roughly speaking (for intution), two types are convertible up to evaluation, e.g. $(\lambda x. x) A \equiv A$.

\subsubsection{Judgemental Equality}
Given two convertible types $A$ and $B$, and two terms $x : A$, $y : B$, we define judgemental equality between $x$ and $y$ as a congruent equality relation, with $\beta$ and $\eta$ rules for Singletons.

\begin{figure*}[h]
  \[
    \inference[JE-Refl]{\Gamma \vdash t : A}
                    {\Gamma \vdash (t : A) \equiv (t : A) \dashv \Gamma}
    \quad
    \inference[JE-Sym]{\Gamma \vdash (t : A) \equiv (s : B) \dashv \Delta}
                     {\Delta \vdash (s : B) \equiv (t : A) \dashv \Gamma}
  \]

  \[
    \inference[JE-Trans]{\Gamma \vdash (t : A) \equiv (s : B) \dashv \Delta & \Delta \vdash (s : B) \equiv (r : C) \dashv \Xi}
                     {\Gamma \vdash (t : A) \equiv (r : C) \dashv \Xi}
  \]

  \caption*{Judgemental Equality Equivalence Relation Laws}
  \label{fig:dt-singletons-je-er}
\end{figure*}

\begin{figure*}[h]
  \[
    \inference[JE-\true-Cong]{}
                    {\Gamma \vdash (\true : \Bool) \equiv (\true : \Bool) \dashv \Delta}
  \]
  \[
    \inference[JE-\false-Cong]{}
                    {\Gamma \vdash (\false : \Bool) \equiv (\false : \Bool) \dashv \Delta}
  \]

  \[
  \inference[JE-\tm{when}-Cong]
            { \Gamma \vdash (x : \Bool) \equiv (x' : \Bool) \dashv \Delta
            & \Gamma \vdash (c : \Bool) \equiv (c' : \Bool) \dashv \Delta
            \\ \Gamma \vdash (t : A) \equiv (t' : A') \dashv \Delta
            & \Gamma \vdash (e : A) \equiv (e' : A') \dashv \Delta
            }
            {\Gamma \vdash (\when c x A t e : A[x \mapsto c])
            \\ \equiv (\when{c'}{x'}{A'}{t'}{e'} : A'[x' \mapsto c']) \dashv \Delta}
  \]

  \[
    \inference[JE-\val-Cong]{\Gamma \vdash (t : A) \equiv (s : B) \dashv \Delta}
                     {\Gamma \vdash (\val[A][t] : \Singleton[A][t]) \equiv (\val[B][s] : \Singleton[B][s]) \dashv \Delta}
  \]

  \caption*{Judgemental Equality Congruences}
  \label{fig:dt-singletons-je-cong}
\end{figure*}

\subsection{Equational System}
We define constructors and eliminators for our types.

\begin{figure*}[h]
  \[
  \inference[\Intro{$\Singleton$}]
            { \Gamma \vdash t : A
            & \Gamma \vdash s : B
            & \Gamma \vdash (t : A) \equiv (s : B) \dashv \Delta
            }
            {\Gamma \vdash \val[A][t] : \Singleton[B][s]}
  \]

  \[
  \inference[\Elim{$\Singleton$}]
            {\Gamma \vdash t : \Singleton[A][s]
            & \Gamma, (x : A) \equiv s \vdash r : B}
            {\Gamma \vdash \letval x t r : B}
  \]

  \caption*{$\Singleton$ Intro/Elim}
  \label{fig:dt-singletons-singleton-intro-elim}
\end{figure*}

\begin{figure*}[h]
  \[
  \inference[\Intro{$\Bool$}$_{\true}$]{}
            {\Gamma \vdash \true : \Bool}
  \quad
  \inference[\Intro{$\Bool$}$_{\false}$]{}
            {\Gamma \vdash \false : \Bool}
  \]

  \[
  \inference[\Elim{$\Bool$}]
            {\Gamma \vdash c : \Bool
            \\ \Gamma, (\ford : \Singleton[\Bool][c]) \equiv \val[\Bool][\true] \vdash t : A[x \mapsto \true]
            \\ \Gamma, (\ford : \Singleton[\Bool][c]) \equiv \val[\Bool][\false] \vdash e : A[x \mapsto \false]
            }
            {\Gamma \vdash \when c x A t e : A : A[x \mapsto c]}
  \]

  \caption*{$\Bool$ Intro/Elim}
  \label{fig:dt-singletons-bool-intro-elim}
\end{figure*}

\jtodo{Fix Bool-Elim to be dependent}

\jq{Conv on bool-elim for cond (i.e. $c : C$, $C \equiv \Bool$)? Our conv rel on bools is trivial so it makes no difference but I'm wondering if it would be more precise to include it anyway}
\jq{Arbitrarily picking A as a return type in bool-elim, but should I introduce a third type and enforce conv between it, A, and B?}


\begin{figure*}[h]
  \[
  \inference[$\Singleton$-$\beta$]
            { \Gamma \vdash \letval x {\val[A][t]} x : A
            }
            {\Gamma \vdash t : A}
  \]

  \begin{equation}
    \tag{$\Singleton$-$\beta$}
    \letval x {\val[A][t]} x \equiv t
  \end{equation}

  \begin{equation}
    \tag{$\Bool$-$\beta_{\true}$}
    \when \true x A t e \equiv t
  \end{equation}

  \begin{equation}
    \tag{$\Bool$-$\beta_{\false}2$}
    \ite \false x A t e \equiv e
  \end{equation}

  \caption*{$\beta$ rules}
  \label{fig:dt-singletons-beta}
\end{figure*}

\begin{figure*}[h]
  \begin{equation}
    \tag{$\Bool$-$\eta$}
    \ite c x A \true \false \equiv c
  \end{equation}

  \[
  \inference[$\Bool$-$\eta$]
            { \Gamma \vdash c : \Bool}
            {\Gamma \vdash \ite c x A \true \false : Bool}
  \]

  \caption*{$\eta$ rules}
  \label{fig:dt-singletons-eta}
\end{figure*}

We don't define an $\eta$ rule for $\Singleton$, as it would require introducing many more features to our calculus than we care about.
