\section{Base Dependent Types}
When moving from STLC to dependent types, our judgements themselves become more complicated.
To keep things simple, we'll only consider the simplest possible dependent type: the singleton.
In order to make the calculus non-trivial, we'll include the booleans as a base type.

\subsection{Presyntax}
Our calculus is defined over precontexts $\Gamma$, pretypes $A$, and preterms $s, t, r$.

\begin{bnf}
$\Gamma$ ::=
  | $\cdot$ : Empty context
  | $\Gamma, x \colon S$ : Variable weakening
  | $\Gamma, (x \colon A) \equiv t$ : Definition weakening
;;
$A$ ::=
  | $\Bool$ : Booleans
  | $\Singleton[A][t]$ : The singleton of $t \,\colon A$
;;
$s, t, r$ ::=
| $\true$ : Boolean value constructors
| $\false$
| $\ite{s}{t}{r}$ : Boolean eliminator
| $\val[A][t]$ : Value constructor for $\Singleton[A][t]$
\end{bnf}


\subsection{Judgements}
\subsubsection{Contexts}
Our contexts are snoclists of either variables (with associated types), or definitions (a variable paired with a term).
We have a judgement to declare that $\Gamma$ is a valid context:
\[
  \vdash \ctx{\Gamma}
\]

All empty contexts are valid:
\[
  \inference[Ctx-Emp]{}{\vdash \ctx{\cdot}}
\]

Given a valid context $\Gamma$, we can extend it with a variable:
\[
  \inference[Ctx-ExtVar]
  {\Gamma \vdash x : A}
  {\vdash \ctx{\Gamma, x : A}}
\]

Or, we can extend it with a definition:
\[
  \inference[Ctx-ExtLet]
  {\Gamma \vdash t : A}
  {\vdash \ctx{\Gamma, (x : A) \equiv t}}
\]
$x$ in this rule is just a name that refers to the term $t$.
We can envision this as a let binding.
We can think of our variables as de-Bruijn indexed, so shadowing isn't an issue.

For implementation, we consider the support of a context (i.e., the names of the variables used by said context).
It's too much work to index our terms by their contexts, since we have to keep track of dependencies, so instead we index terms by their support.

\subsubsection{Types}
$A$ is a valid type in context $\Gamma$:
\[
  \Gamma \vdash \type{A}
\]

\subsubsection{Terms}
$t$ is a well typed term of type $A$ in context $\Gamma$:
\[
  \Gamma \vdash t : A
\]

\subsection{Relations}
We have three relations that we need to worry about, acting on contexts, types, and terms. We'll call them twinning, convertibility, and judgemental equality respectively.

\subsubsection{Twinning}
Gundry's twin variables \cite{gundry2013TypeInferenceHaskell} \cite{gundry2013TutorialImplementationDynamic} allow us to ``twin'' the same variable appearing in two terms with two different types.
\[
  \inference[Twin-Emp]{}{\cdot \frown \cdot}
\]
\[
  \inference[Twin-ExtVar]
    { \Gamma \frown \Delta
    & \Gamma \vdash A \equiv B \dashv \Delta
    }
    { \Gamma, x : A \frown \Delta, y : B }
\]

\[
  \inference[Twin-ExtLet]
  { \twin{\Gamma}{\Delta}
  & \Gamma \vdash (t : A) \equiv (s : B) \dashv \Delta
  }
  {\twin{\Gamma, (x : A) \equiv t}{\Delta, (y : B) \equiv s}}
\]

The twinning relation between contexts $\Gamma$ and $\Delta$ effectively allows us to ensure that each variable in $\Gamma$ has the same shape (up to convertibility) as the corresponding variable (i.e. the variable at the same position) in $\Delta$.

\subsubsection{Convertibility}
Given two types $A$ and $B$, we define convertibility on $A$ and $B$ (writ $\Gamma \vdash A \equiv B \dashv \Delta$) inductively. Assume $\Gamma \frown \Delta$.

\[
\inference[Conv-Bool]{}{\Gamma \vdash \Bool \equiv \Bool \dashv \Gamma}
\]
(and the same for any other base type)

For the singleton type:
\[
\inference[Conv-$\Singleton$]
    { \Gamma \vdash A \equiv B \dashv \Delta
    & \Gamma \vdash (t : A) \equiv (s : B) \dashv \Delta
    }
    { \Gamma \vdash \Singleton[A][t] \equiv \Singleton[A][t] \dashv \Delta }
\]

Roughly speaking (for intution), two types are convertible up to evaluation, e.g. $(\lambda x. x) A \equiv A$.

\subsubsection{Judgemental Equality}
Given two convertible types $A$ and $B$, and two terms $x : A$, $y : B$, we define judgemental equality between $x$ and $y$ as a congruent equality relation, with beta and eta rules for Singletons.

\begin{figure*}[h]
  \[
    \inference[JE-Refl]{\Gamma \vdash t : A}
                    {\Gamma \vdash (t : A) \equiv (t : A) \dashv \Gamma}
    \quad
    \inference[JE-Sym]{\Gamma \vdash (t : A) \equiv (s : B) \dashv \Delta}
                     {\Delta \vdash (s : B) \equiv (t : A) \dashv \Gamma}
  \]

  \[
    \inference[JE-Trans]{\Gamma \vdash (t : A) \equiv (s : B) \dashv \Delta & \Delta \vdash (s : B) \equiv (r : C) \dashv \Xi}
                     {\Gamma \vdash (t : A) \equiv (r : C) \dashv \Xi}
  \]

  \[
    \inference[JE-Cong]{\Gamma \vdash A \equiv B \dashv \Delta & \Gamma \vdash (t : A) \equiv (s : B) \dashv \Delta}
                     {\Gamma \vdash (t : A) \equiv (s : B)}
  \]

  \caption*{Judgemental Equality Rules}
  \label{fig:base-dt-je-rules}
\end{figure*}

\jtodo{Should we force $A$ on both sides in JE-Sym or force convertibility?}
\jtodo{Congruence?}

\subsection{Equational System}

We don't define an $\eta$ rule for $\Singleton$, as it would require introducing many more features to our calculus than we care about.

\begin{figure*}[h]
  \[
  \inference[\Intro{$\Singleton$}]
            { \Gamma \vdash t : A
            & \Gamma \vdash s : B
            & \Gamma \vdash A \equiv B \dashv \Delta
            & \Gamma \vdash (t : A) \equiv (s : B) \dashv \Delta
            }
            {\Gamma \vdash \val[][t] : \Singleton[B][s]}
  \]

  \[
  \inference[\Elim{$\Singleton$}]
            {\Gamma \vdash t : \Singleton[A][t]
            & \Gamma \vdash (t : \Singleton[A][t]) \equiv (s : \Singleton[A][s]) \dashv \Gamma
            & \Gamma, (x : A) \equiv s \vdash \type B}
            {\Gamma \vdash \letval x t r : B}
  \]

  \caption*{$\Singleton$ Intro/Elim}
  \label{fig:base-dt-singleton-beta-eta}
\end{figure*}

\begin{figure*}[h]
  \[
  \inference[\Intro{$\Bool$}$_{\true}$]{}
            {\Gamma \vdash \true : \Bool}
  \quad
  \inference[\Intro{$\Bool$}$_{\false}$]{}
            {\Gamma \vdash \false : \Bool}
  \]

  \[
  \inference[\Elim{$\Bool$}]
            {\Gamma \vdash c : \Bool
            & t : A
            & e : B
            & \Gamma \vdash A \equiv B \dashv \Delta
            }
            {\Gamma \vdash \ite c t e : A}
  \]

  \caption*{$\Bool$ Intro/Elim}
  \label{fig:base-dt-singleton-beta-eta}
\end{figure*}

\jtodo{Conv on bool elim for cond? Our conv rel on bools is trivial so it makes no difference but I'm wondering if it would be more precise to include it anyway}
\jtodo{Arbitrarily picking A as a return type in elim, but should I introduce a third type and enforce conv between it, A, and B?}


\begin{figure*}[h]
  \[
  \inference[$\Singleton$-$\beta$]
            { \Gamma \vdash \letval x {\val[A][t]} x : A
            }
            {\Gamma \vdash t : A}
  \]

  \caption*{$\beta$ rules}
  \label{fig:base-dt-singleton-beta-eta}
\end{figure*}

\jtodo{Beta/Eta for bools?}
